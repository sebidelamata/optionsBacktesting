---
output: html_document
title: 'Gamma Gamma Hey (an options analysis) Part Two:'
layout: post
---

# Building Basic Options SME


[Github link](https://github.com/sebidelamata/optionsBacktesting){target="_blank"}

## Abstract

In this post we will use data collected from [post one](https://sebidelamata.github.io/datascienceblog/2022/06/12/Gamma-Gamma-Hey-Part-One.html){target="_blank"} to educate ourselves on the basics behind option valuation as well as some common strategies used in option trading. To accomplish this we will be creating a series of functions as well as visualize some real world trades with Plotly. 

## Single Option Valuation

Equity options generally serve as a contract giving the owner the right to sell (a put) or buy (a call) 100 shares of the underlying at a given price. We will start of modeling these as European style options to start for the sake of simplicity. European options can be exercised at the date of expiration, where American style options allow for early exercise up to and including the date of expiration.

### Call Options

As stated before, equity call options give the owner the right buy 100 shares of the underlying at a given price. The value of this contract has a convex payoff structure compared to the underlying. The contract will be worth nothing if it expires before the underlying price has surpassed the strike price of the contract. It will otherwise be worth the difference between the market price of the underlying and the strike price of the contract. This basic payoff function can be modeled like so:

```{r}

library(dplyr)

# The payoff for a call buyer at expiration date T is given by 
# max(0, ST â€“ X)
call_buyer_payoff <- function(underlying_price_expiration, strike_price){
  
  # either zero or the difference in the strike and expiration
  max(0, underlying_price_expiration - strike_price)
  
}

```

We can model the call buyer payoff for a near-the-money QQQ Jan 20th, 2023 call if we had bought the option on Friday, July 1st 2022. First, we need to grab the data from our PostgreSQL database. We went ahead and made the query process into a function as we will be repeating this a lot.

```{r}
source("./query_sebis_pi.R")


# our query (grab the whole option chain for that expiration)
sql_query_string <- "SELECT * FROM watchlist_data WHERE scrape_date = '2022-07-01' AND underlying_ticker = 'QQQ' AND expiration_date = '2023-01-20';"

data_pull <- query_sebis_pi(sql_query_string)

```

Now we can apply our function to a series of possible expiration prices.


```{r}

data_pull$mid <- (data_pull$bid + data_pull$ask) / 2

# select the at the money
qqq_atm_call_jan_twenty <- data_pull[data_pull$strike_price == 280 & data_pull$contract_type == "C",]

two_fifty_call_payoff <- sapply(
  seq(250,400, 0.01),
  FUN = function(x){
    call_buyer_payoff(
      underlying_price_expiration = x, 
      strike_price = qqq_atm_call_jan_twenty$strike_price
      )
    }
)

# create a df to hold values with possible strikes at expiration
two_fifty_call_payoff <- data.frame(
  possible_profits = two_fifty_call_payoff,
  possible_expiration_prices = seq(250, 400, 0.01)
)

```

Let's plot our potential payoffs.

```{r}

# create a quick function to plot our payouts (we'll be doing a few)
# plotting our payoff functions (plotly)
# takes a profit df (2 columns profits and strikes)
# and a Title for the plot
lineplot_profit <- function(profit_df, title, option_chain_df){
  
  library(ggplot2)
  library(plotly)
  library(scales)
  library(wesanderson)
  
  profit_lineplot <- ggplot(
    data = profit_df,
    aes(
      x = possible_expiration_prices,
      y = possible_profits
    )
  ) +
    geom_line(color = wesanderson::wes_palette("Royal1")[3]) +
    ggtitle(title) +
    xlab("Possible Expiration Prices") +
    ylab("Profit (USD $)") +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = wes_palette("Darjeeling2")[5], color = wes_palette("Darjeeling2")[5]),
      plot.background = element_rect(fill = wes_palette("Darjeeling2")[5], color = wes_palette("Darjeeling2")[5]),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(color = wesanderson::wes_palette("Royal1")[3]),
      axis.text.y = element_text(color = wesanderson::wes_palette("Royal1")[3]),
      legend.position = "none",
      text = element_text(color = wesanderson::wes_palette("Royal1")[3])
      ) +
    scale_y_continuous(
      labels = scales::dollar_format(),
      limits = c(
        min(profit_df$possible_profits) - abs(min(profit_df$possible_profits)),
        max(profit_df$possible_profits) + abs(max(profit_df$possible_profits))
        )
      ) +
    scale_x_continuous(labels = scales::dollar_format()) +
    geom_hline(
      yintercept = 0,
      linetype = "dashed",
      color = wesanderson::wes_palette("Royal1")[3],
      size = 0.3
      ) +
    geom_vline(
      xintercept = option_chain_df$underlying_close[1],
      linetype = "dashed",
      color = "white",
      size = 0.075
    ) +
    scale_color_manual(values = wesanderson::wes_palette("Royal1")[3])
  
  profit_lineplot <- plotly::ggplotly(profit_lineplot)
                      
  return(profit_lineplot)
  
}

# now let's plot our payout
two_fifty_call_payoff <- lineplot_profit(
  two_fifty_call_payoff, 
  "Payoff, Long the Jan 20th, 2023 $280 Call",
  qqq_atm_call_jan_twenty
  )


two_fifty_call_payoff

```

To clarify, the above shows the payoff on a per-share basis. This also excludes the price the call buyer has to pay for the contract (the premium). To incorporate the cost of the contract we can build the following function off of our previous function. 

```{r}

# profit is equal to payoff minus the initial premium
call_buyer_profit <- function(underlying_price_expiration, strike_price, option_price){
  100 * (call_buyer_payoff(underlying_price_expiration, strike_price) - option_price)
}

```

Notice that this function multiplies the outcome by 100, giving us the profit of the contract, where before where we looked at payoff on a per-share basis. Now let's model the same QQQ contract as before.

```{r}

# apply our profit function
two_fifty_call_payoff <- sapply(
  seq(250,400, 0.01),
  FUN = function(x){
    call_buyer_profit(
      underlying_price_expiration = x, 
      strike_price = qqq_atm_call_jan_twenty$strike_price,
      option_price = qqq_atm_call_jan_twenty$mid
      )
    }
)

# create a df to hold values with possible strikes at expiration
two_fifty_call_payoff <- data.frame(
  possible_profits = two_fifty_call_payoff,
  possible_expiration_prices = seq(250, 400, 0.01)
)

# now let's plot our profit
two_fifty_call_profit <- lineplot_profit(
  two_fifty_call_payoff, 
  "Profit, Long the Jan 20th, 2023 $280 Call",
  qqq_atm_call_jan_twenty
  )


two_fifty_call_profit

```

On the other side of this trade is the call seller. Their profit is simply the inverse of the buyer.

```{r}

# seller payoff is inverse of buyer payoff
call_seller_payoff <- function(underlying_price_expiration, strike_price){
  -call_buyer_payoff(underlying_price_expiration, strike_price)
}


# seller profit is seller payout plus what they originally received for selling the option
call_seller_profit <- function(underlying_price_expiration, strike_price, option_price){
  100 * (call_seller_payoff(underlying_price_expiration, strike_price) + option_price)
}


```

Now we can model the same call as before, but from the other side of the trade.

```{r}

# apply our profit function
two_fifty_call_payoff <- sapply(
  seq(250,400, 0.01),
  FUN = function(x){
    call_seller_profit(
      underlying_price_expiration = x, 
      strike_price = qqq_atm_call_jan_twenty$strike_price,
      option_price = qqq_atm_call_jan_twenty$mid
      )
    }
)

# create a df to hold values with possible strikes at expiration
two_fifty_call_payoff <- data.frame(
  possible_profits = two_fifty_call_payoff,
  possible_expiration_prices = seq(250, 400, 0.01)
)

# now let's plot our profit
two_fifty_call_profit <- lineplot_profit(
  two_fifty_call_payoff, 
  "Profit, Short the Jan 20th, 2023 $280 Call",
  qqq_atm_call_jan_twenty
  )


two_fifty_call_profit

```

Notice that unlike before where maximum loss is defined and profit is undefined, selling a call has a defined maximum profit (the premium received from selling the contract) and an undefined loss. Some throw the term "unlimited" or "infinite" around, but this is deceiving. 


### Put Options

An equity put contract gives the holder of the contract the right to force someone to buy 100 shares at a given strike price. We can calculate the payoff for a put buyer by reversing the order we used to calculate call payoff (now using strike - expiration).

```{r}

# put buyer payout is the opposite order (strike minus expiration) from the call buyer
put_buyer_payoff <- function(underlying_price_expiration, strike_price){
  
  # either zero or the strike prize minus expiration
  max(0, strike_price - underlying_price_expiration)

}

```

Now let's apply the put payoff function to the same strike and expiration contract for QQQ that we used on the call.

```{r}

# select the at the money
qqq_atm_put_jan_twenty <- data_pull[data_pull$strike_price == 280 & data_pull$contract_type == "P",]

two_fifty_put_payoff <- sapply(
  seq(100,300, 0.01),
  FUN = function(x){
    put_buyer_payoff(
      underlying_price_expiration = x, 
      strike_price = qqq_atm_put_jan_twenty$strike_price
      )
    }
)

# create a df to hold values with possible strikes at expiration
two_fifty_put_payoff <- data.frame(
  possible_profits = two_fifty_put_payoff,
  possible_expiration_prices = seq(100, 300, 0.01)
)

# now let's plot our payout
two_fifty_put_payoff <- lineplot_profit(
  two_fifty_put_payoff, 
  "Payoff, Long the Jan 20th, 2023 $280 Put",
  qqq_atm_put_jan_twenty
  )


two_fifty_put_payoff

```

We also have to take into account the cost of the contract premium, similar to what we did with our call. 


```{r}

# put buyer profit equals payoff minus initial premium paid
put_buyer_profit <- function(underlying_price_expiration, strike_price, option_price){
  100 * (put_buyer_payoff(underlying_price_expiration, strike_price) - option_price)
}

```

Let's apply this to the same put contract.

```{r}

# apply our profit function
two_fifty_put_payoff <- sapply(
  seq(100,300, 0.01),
  FUN = function(x){
    put_buyer_profit(
      underlying_price_expiration = x, 
      strike_price = qqq_atm_put_jan_twenty$strike_price,
      option_price = qqq_atm_put_jan_twenty$mid
      )
    }
)

# create a df to hold values with possible strikes at expiration
two_fifty_put_payoff <- data.frame(
  possible_profits = two_fifty_put_payoff,
  possible_expiration_prices = seq(100, 300, 0.01)
)

# now let's plot our profit
two_fifty_put_profit <- lineplot_profit(
  two_fifty_put_payoff, 
  "Profit, Long the Jan 20th, 2023 $280 Put",
  qqq_atm_put_jan_twenty
  )


two_fifty_put_profit

```

We also of course have a seller where we have a buyer. We also model this similarly to the calls

```{r}

# seller payoff is inverse of buyer payoff
put_seller_payoff <- function(underlying_price_expiration, strike_price){
  -put_buyer_payoff(underlying_price_expiration, strike_price)
}


# seller profit is seller payout plus what they originally received for selling the option
put_seller_profit <- function(underlying_price_expiration, strike_price, option_price){
  100 * (put_seller_payoff(underlying_price_expiration, strike_price) + option_price)
}


```

Now let's model this on our same QQQ put.

```{r}

# apply our profit function
two_fifty_put_payoff <- sapply(
  seq(100,300, 0.01),
  FUN = function(x){
    put_seller_profit(
      underlying_price_expiration = x, 
      strike_price = qqq_atm_put_jan_twenty$strike_price,
      option_price = qqq_atm_put_jan_twenty$mid
      )
    }
)

# create a df to hold values with possible strikes at expiration
two_fifty_put_payoff <- data.frame(
  possible_profits = two_fifty_put_payoff,
  possible_expiration_prices = seq(100, 300, 0.01)
)

# now let's plot our profit
two_fifty_put_profit <- lineplot_profit(
  two_fifty_put_payoff, 
  "Profit, Short the Jan 20th, 2023 $280 Put",
  qqq_atm_put_jan_twenty
  )


two_fifty_put_profit

```

## Basic Point-in-Time Option Spread Strategies


### Reducing the cost basis of equity positions

A common strategy to reduce cost basis of a position is the covered call or covered put strategy. This involves either the selling of a call against a long position of 100 shares or the selling of a put against a short position of 100 shares. Lets first create a function to model buying 100 shares (using our data as an input).

```{r}

# let's create a profit function for holding 100 shares
buy_hundred_shares_profit <- function(option_chain_df){
  
  # create a sequence of possible closing prices
  possible_closing_prices <- seq(
    0, 
    max(option_chain_df[,"strike_price"]), 
    0.01
  )
  
  # apply our vector to the profit function
  buy_hundred_shares_profit <- sapply(
    possible_closing_prices, 
    function(closing_price){
      (closing_price * 100) - (option_chain_df$underlying_close[1] * 100) 
    }
    )
  
  # we will call it expiration so it works with the 
  # plotting function but its really trade exit price
  buy_hundred_shares_profit_df <- data.frame(
    possible_expiration_prices = possible_closing_prices,
    possible_profits = buy_hundred_shares_profit
  )
  
  # return our dataframe
  return(buy_hundred_shares_profit_df)
  
}

```

Let's grab our plotting function we made so we don't have to do all of that code again.

```{r}

source("./plotting_functions.R")

```

Now let's look at the possible profit from holding a 100 shares long of QQQ at a range of given prices.

```{r}

lineplot_profit(
  buy_hundred_shares_profit(
    data_pull
    ),
  paste0("Profit, Long 100 shares QQQ\nCost Basis: $", as.character(data_pull$underlying_close[1] * 100)),
  data_pull
)

```

Now let's look at the premium we would receive for selling the QQQ Jan 20th, 2023 $355 Call.

```{r}

# create a sequence of possible closing prices
possible_closing_prices <- seq(
  0, 
  max(data_pull[,"strike_price"]), 
  0.01
)
  
# apply our vector to the profit function
possible_profits <- sapply(
  possible_closing_prices, 
  FUN = function(x){
    call_seller_profit(
      underlying_price_expiration = x, 
      strike_price = 355, 
      option_price =  data_pull[data_pull$strike_price == 355 & data_pull$contract_type == "C", "mid"]
    )
    }
  )

sample_sell_call_profit <- data.frame(
    possible_expiration_prices = possible_closing_prices,
    possible_profits = possible_profits
  )

lineplot_profit(
  sample_sell_call_profit,
  "Profit, Short QQQ Jan 20th, 2023 $355 Call",
  data_pull
  )

```

Now let's look at what happens when we combine these two trades. Our upside is capped, but our cost basis has been reduced on trade entry. To fund the profit we simply sum the two data frames containing our prospective profit. For the sake of not repeating a whole bunch of code, let's go ahead and source the script containing all of the payout and profit functions we have written.

```{r}

source("payout_functions.R")

```

Now let's model buying 100 shares of QQQ and selling the Jan 20th, 2023 \$355 Call against the position at the same time.

```{r}

lineplot_profit(
  covered_call_profit(
    data_pull, 
    355
    ),
  paste0(
  "Profit, Long 100 shares QQQ\nShort the Jan 20th 2023 $355 Call\nCost Basis: $",
  as.character((data_pull$underlying_close[1] * 100) - (data_pull[data_pull$strike_price == 355 & data_pull$contract_type == "C", "mid"] * 100))
  ),
  data_pull
)

```


Buying and selling calls and/or puts at different strikes can provide payoff structures that provide some advantages. They can allow us to define our maximum gain and/or loss in a situation where it would otherwise be undefined. Spreads can also offer lower capital requirements to take on a position than would a "naked" (single option) position. In addition, spreads can be used to target aspects associated with the Greeks (variables associated with the Black-Scholes Model).

### Long Vertical Spreads (Debit Spreads)

Long vertical spreads are constructed by simultaneously buying a contract and selling another at a different strike for a net initial cost. The premium obtained up-front from selling one contract finances the long leg. This position insures that the long leg will be further in-the-money than the short leg, meaning if the short leg is breached the trade will have reached maximum profit. Let's first look at the payoff for a bullish call vertical spread starting with just a Jan 20, 2023 QQQ $280 Call.

```{r}

lineplot_profit(
  long_call_profit(
    qqq_atm_call_jan_twenty, 
    280
    ), 
  "Profit, Long the QQQ Jan 20th, 2023 $280 Call",
  qqq_atm_call_jan_twenty
  )

```

Our up-front cost of buying this call is \$4,219.50. We would all of our initial investment if QQQ closed below \$280.00 on Jan 20th (barring early exercise), and we would not start to profit until QQQ surpassed \$322.19. Now let's look at what happens if we sold a call five dollars further out of the money.

```{r}

lineplot_profit(
  short_call_profit(
    data_pull,
    285
  ),
  "Profit, Short the QQQ Jan 20th, 2023 Call",
  data_pull
)

```

If we sold this call we would receive an upfront payment of \$2,528.00. We would not start losing money on this trade until the price of QQQ moved past \$310.27. As we saw before, the profit structure is the opposite to the long call, although this time at a different (higher) strike. If we made both of these trades simultaneously, our profit structure is merely the sum of the two trades at each strike. The function I created in R does basically this: runs the profit for the long leg, then the short leg, then combines these into a single data frame and sums the two payoffs. The result of this spread is a bullish trade with a capped upside and reduced downside risk.

```{r}

lineplot_profit(
  call_vertical_profit(
    data_pull,
    280,
    285
  ),
  "Profit, QQQ Jan 20th, 2023:\nLong the $280 Call, Short the $285 Call",
  data_pull
)

```

We can mirror a vertical debit spread for a put by buying a put and selling another further out-of-the-money. This gives us a spread that trades bearish with capped potential profits and reduced entry cost. Again here is a single long put (lets choose slightly out of the money).

```{r}


lineplot_profit(
  long_put_profit(
    data_pull,
    270
  ),
  "Profit, Long QQQ Jan 20th, 2023 $270 Put",
  data_pull
)

```

And if we sold the \$265 (further out-of-the-money) put:

```{r}


lineplot_profit(
  short_put_profit(
    data_pull,
    265
  ),
  "Profit, Short QQQ Jan 20th, 2023 $265 Put",
  data_pull
)

```

The function to calculate the profits from the put vertical spread is again simply the sum of the long and short payoffs.

```{r}

lineplot_profit(
  put_vertical_profit(
    data_pull,
    270,
    265
  ),
  "Profit, QQQ Jan 20th, 2023:\nLong the $270 Put, Short the $265 Put",
  data_pull
)


```

### Short Vertical Spreads (Credit Spreads)

Just like we can use a spread trade for a net long position, we can create a net short position. Let's look at the inverse of the call debit spread position we just illustrated. First we sell a call closer to the money.

```{r}

lineplot_profit(
  short_call_profit(
    qqq_atm_call_jan_twenty, 
    280
    ), 
  "Profit, Short the QQQ Jan 20th, 2023 $280 Call",
  data_pull
  )


```

Then we buy a call further from the money (the opposite of a debit spread).

```{r}

lineplot_profit(
  long_call_profit(
    data_pull,
    285
  ),
  "Profit, Long the QQQ Jan 20th, 2023 Call",
  data_pull
)

```

The result is a spread that allows us to take a short position and define the risk of the trade (otherwise undefined when selling a call). If you look at the code below, you will notice it is identical to the code for the debit spread except with the strikes reversed.

```{r}

lineplot_profit(
  call_vertical_profit(
    data_pull,
    285,
    280
  ),
  "Profit, QQQ Jan 20th, 2023:\nShort the $280 Call, Long the $285 Call",
  data_pull
)

```

We can also use a short put vertical spread to create a bullish position that receives a credit up front with reduced cost of entry compared to selling the naked put. Here is the same put spread we did before, but with the strikes reversed to make it a net short position.

```{r}

lineplot_profit(
  put_vertical_profit(
    data_pull,
    265,
    270
  ),
  "Profit, QQQ Jan 20th, 2023:\nShort the $270 Put, Long the $265 Put",
  data_pull
)

```

### Short and Long Iron Condors/Butterflies

Though the name seemss exotic, Iron Condors are simply a put vertical spread combined with a call spread. This sounds counter intuitive, selling both the call side and the put side allows us to create a delta-neutral position (a position that derives value from volatility and time decay rather than being right on direction). Selling both sides allows us push both spreads out and collect the same credit. The logic for modeling this trade is exactly the same as in our vertical spreads where we sum our two data frames to of each leg's profit to get our total profit. The iron condor function simply calls a call vertical function and a put vertical function to each perform the summing of their legs, then again sums the results of both of these "wings" of our condor to arrive at our final result. Let's plot a short Iron Condor that collects \$419.50 of premium up front and risks a max loss of \$580.50.

```{r}

lineplot_profit(
  iron_condor_profit(
    option_chain_df = data_pull,
    340,
    330,
    230,
    240
  ),
  "Iron Condor, QQQ Jan 20, 2023:\nShort the $330 Call, Long the $340\nShort the $240 Put, Long the $230",
  data_pull
)

```

A long condor would simply be the opposit of the previous trade. This trade would profit given a big move in either direction (or a significant increase in volatility as this position is a net debit).

```{r}

lineplot_profit(
  iron_condor_profit(
    option_chain_df = data_pull,
    330,
    340,
    240,
    230
  ),
  "Iron Condor, QQQ Jan 20, 2023:\nLong the $330 Call, Short the $340\nLong the $240 Put, Short the $230",
  data_pull
)

```

An Iron Butterfly is very similar to an Iron Condor, except that both of the closer to the money contracts share the same strike (usually near-the-money). The short Iron Butterfly illustrated here creates for much higher risk-reward ratio (in this case ~15.5:1), albeit at the cost of a lot of potential risk management and related trade commissions from having to adjust the strikes.

```{r}

lineplot_profit(
  iron_condor_profit(
    option_chain_df = data_pull,
    290,
    280,
    270,
    280
  ),
  "Iron Condor, QQQ Jan 20, 2023:\nShort the $380 Call, Long the $340\nShort the $280 Put, Long the $230",
  data_pull
)

```

The long Iron Butterfly provides the opposite scenario: a low payout (~6.5%) for a very wide range of strikes with a very extreme downside scenario.

```{r}

lineplot_profit(
  iron_condor_profit(
    option_chain_df = data_pull,
    280,
    290,
    280,
    270
  ),
  "Iron Condor, QQQ Jan 20, 2023:\nShort the $380 Call, Long the $340\nShort the $280 Put, Long the $230",
  data_pull
)

```